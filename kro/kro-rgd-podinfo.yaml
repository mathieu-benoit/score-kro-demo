apiVersion: kro.run/v1alpha1
kind: ResourceGraphDefinition
metadata:
  name: workload-app
spec:
  schema:
    apiVersion: v1alpha1
    kind: Workload
    spec:
      name:            string  | required=true
      replicas:        integer | default=2 minimum=1 maximum=50
      image:           string
      imagePullPolicy: string  | default="IfNotPresent"

      # Env
      envConfigMapName: string | default="env-configmap"

      # Ports (scalars) --> we'll find another way later
      httpPort:        integer | default=9898 minimum=1 maximum=65535
      metricsPort:     integer | default=9797 minimum=1 maximum=65535
      grpcPort:        integer | default=9999 minimum=1 maximum=65535

      # Optional HTTPRoute (boolean + strings)
      createHTTPRoute: boolean | default=false
      hostname:        string  | required=false
      routePath:       string  | default="/"
      gatewayName:     string  | default="default"

      # --- Security & resources knobs ---
      automountSAToken:           boolean | default=false
      readOnlyRootFilesystem:     boolean | default=true
      allowPrivilegeEscalation:   boolean | default=false
      runAsUser:                  integer | default=65532 minimum=1000
      runAsGroup:                 integer | default=65532 minimum=1000
      fsGroup:                    integer | default=65532 minimum=1

      cpuRequest:                 string  | default="100m"
      cpuLimit:                   string  | default="500m"
      memoryRequest:              string  | default="128Mi"
      memoryLimit:                string  | default="512Mi"

      # HPA (autoscaling/v2)
      enableHPA:                  boolean | default=true
      minReplicas:                integer | default=2 minimum=1
      maxReplicas:                integer | default=10 minimum=1
      targetCPUUtilization:       integer | default=70 minimum=1 maximum=100
      targetMemoryUtilization:    integer | default=80 minimum=1 maximum=100

      # Optional add-ons
      enableNetworkPolicy:        boolean | default=true
      enablePDB:                  boolean | default=true
      pdbMinAvailable:            string  | default="50%"

      enableRbac:                 boolean | default=true

    status:
      deploymentConditions: ${deployment.status.conditions}
      availableReplicas:    ${deployment.status.availableReplicas}
      serviceClusterIP:     ${service.spec.clusterIP}
      routeParents:         ${httpRoute.status.parents}

  resources:

    - id: serviceAccount
      template:
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          name: ${schema.spec.name}-sa
        automountServiceAccountToken: ${schema.spec.automountSAToken}

    # Create Role if enableRbac is true
    - id: role
      includeWhen:
        - ${schema.spec.enableRbac}
      template:
        apiVersion: rbac.authorization.k8s.io/v1
        kind: Role
        metadata:
          name: ${schema.spec.name}-role
        rules:
          - apiGroups: [""]
            resources: ["pods", "services"]
            verbs: ["get", "list"]
          - apiGroups: ["apps"]
            resources: ["deployments"]
            verbs: ["get", "list", "watch"]
   # Create RoleBinding if enableRbac is true
    - id: roleBinding
      includeWhen:
        - ${schema.spec.enableRbac}
      template:
        apiVersion: rbac.authorization.k8s.io/v1
        kind: RoleBinding
        metadata:
          name: ${schema.spec.name}-rb
        subjects:
          - kind: ServiceAccount
            name: ${serviceAccount.metadata.name}
        roleRef:
          apiGroup: rbac.authorization.k8s.io
          kind: Role
          name: ${schema.spec.name}-role}

    - id: deployment
      template:
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name:      ${schema.spec.name}
          labels:
            app.kubernetes.io/name: ${schema.spec.name}
        spec:
          replicas: ${schema.spec.replicas}
          selector:
            matchLabels:
              app.kubernetes.io/name: ${schema.spec.name}
          strategy:
            type: RollingUpdate
            rollingUpdate:
              maxSurge: 25%
              maxUnavailable: 1
          template:
            metadata:
              labels:
                app.kubernetes.io/name: ${schema.spec.name}
              annotations:
                prometheus.io/scrape: "true"
                prometheus.io/port:   ${string(schema.spec.httpPort)}
            spec:
              serviceAccountName: ${serviceAccount.metadata.name}
              automountServiceAccountToken: ${schema.spec.automountSAToken}
              securityContext:
                runAsNonRoot: true
                runAsUser:  ${schema.spec.runAsUser}
                runAsGroup: ${schema.spec.runAsGroup}
                fsGroup:    ${schema.spec.fsGroup}
                seccompProfile:
                  type: RuntimeDefault
              volumes:
                - name: data
                  emptyDir: {}
              containers:
                - name: podinfo
                  image: ${schema.spec.image}
                  imagePullPolicy: ${schema.spec.imagePullPolicy}
                  securityContext:
                    allowPrivilegeEscalation: ${schema.spec.allowPrivilegeEscalation}
                    readOnlyRootFilesystem:   ${schema.spec.readOnlyRootFilesystem}
                    capabilities:
                      drop: ["ALL"]
                  command: ["./podinfo"]
                  args:
                    - --port=${schema.spec.httpPort}
                    - --cert-path=/data/cert
                    - --port-metrics=${schema.spec.metricsPort}
                    - --grpc-port=${schema.spec.grpcPort}
                    - --grpc-service-name=podinfo
                    - --level=info
                    - --random-delay=false
                    - --random-error=false
                  envFrom:
                    - configMapRef:
                        name: ${schema.spec.envConfigMapName}
                  ports:
                    - name: http
                      containerPort: ${schema.spec.httpPort}
                      protocol: TCP
                    - name: http-metrics
                      containerPort: ${schema.spec.metricsPort}
                      protocol: TCP
                    - name: grpc
                      containerPort: ${schema.spec.grpcPort}
                      protocol: TCP
                  resources:
                    requests:
                      cpu:    ${schema.spec.cpuRequest}
                      memory: ${schema.spec.memoryRequest}
                    limits:
                      cpu:    ${schema.spec.cpuLimit}
                      memory: ${schema.spec.memoryLimit}
                  volumeMounts:
                    - name: data
                      mountPath: /data
                  livenessProbe:
                    httpGet:
                      path: /healthz
                      port: ${schema.spec.httpPort}
                    initialDelaySeconds: 3
                    periodSeconds: 10
                    timeoutSeconds: 5
                    failureThreshold: 3
                  readinessProbe:
                    httpGet:
                      path: /readyz
                      port: ${schema.spec.httpPort}
                    initialDelaySeconds: 3
                    periodSeconds: 10
                    timeoutSeconds: 5
                    failureThreshold: 3

    - id: service
      template:
        apiVersion: v1
        kind: Service
        metadata:
          name:      ${schema.spec.name}
          labels:
            app.kubernetes.io/name: ${schema.spec.name}
        spec:
          selector:
            app.kubernetes.io/name: ${schema.spec.name}
          type: ClusterIP
          ports:
            - name: http
              port:       ${schema.spec.httpPort}
              protocol:   TCP
              targetPort: http
            - name: grpc
              port:       ${schema.spec.grpcPort}
              protocol:   TCP
              targetPort: grpc

    - id: hpa
      includeWhen:
        - ${schema.spec.enableHPA}
      template:
        apiVersion: autoscaling/v2
        kind: HorizontalPodAutoscaler
        metadata:
          name: ${schema.spec.name}
        spec:
          scaleTargetRef:
            apiVersion: apps/v1
            kind: Deployment
            name: ${deployment.metadata.name}
          minReplicas: ${schema.spec.minReplicas}
          maxReplicas: ${schema.spec.maxReplicas}
          metrics:
            - type: Resource
              resource:
                name: cpu
                target:
                  type: Utilization
                  averageUtilization: ${schema.spec.targetCPUUtilization}
            - type: Resource
              resource:
                name: memory
                target:
                  type: Utilization
                  averageUtilization: ${schema.spec.targetMemoryUtilization}

    - id: netpol
      includeWhen:
        - ${schema.spec.enableNetworkPolicy}
      template:
        apiVersion: networking.k8s.io/v1
        kind: NetworkPolicy
        metadata:
          name: ${schema.spec.name}-default-deny-ingress
        spec:
          podSelector:
            matchLabels:
              app.kubernetes.io/name: ${schema.spec.name}
          policyTypes: ["Ingress","Egress"]
          ingress:
            - from:
                - podSelector: {}   # adjust as needed
              ports:
                - protocol: TCP
                  port: ${schema.spec.httpPort}
          egress:
            - {}  # allow all egress by default

    - id: pdb
      includeWhen:
        - ${schema.spec.enablePDB}
      template:
        apiVersion: policy/v1
        kind: PodDisruptionBudget
        metadata:
          name: ${schema.spec.name}
        spec:
          selector:
            matchLabels:
              app.kubernetes.io/name: ${schema.spec.name}
          minAvailable: ${schema.spec.pdbMinAvailable}

    - id: httpRoute
      includeWhen:
        - ${schema.spec.createHTTPRoute}
      template:
        apiVersion: gateway.networking.k8s.io/v1
        kind: HTTPRoute
        metadata:
          name:      ${schema.spec.name}
        spec:
          hostnames:
            - ${schema.spec.hostname}
          parentRefs:
            - group: gateway.networking.k8s.io
              kind: Gateway
              name: ${schema.spec.gatewayName}
          rules:
            - matches:
                - path:
                    type: PathPrefix
                    value: ${schema.spec.routePath}
              backendRefs:
                - name: ${service.metadata.name}
                  port: ${schema.spec.httpPort}
